Phase 1: Setup & Backend Foundation

1.  **Configure Development Tools:**
    *   Set up Tailwind CSS (if you installed it). This usually involves running an init command and configuring `tailwind.config.js` and your global CSS file.
    *   Configure ESLint and Prettier (if you installed them). Ensure they are set up to lint/format `.svelte`, `.js`, and `.ts` files according to your preferences.
    *   Configure Vitest (if you installed it). Set up the test environment.

2.  **Initialize Prisma:**
    *   Run `npx prisma init` to create the `prisma` directory and the `schema.prisma` file.
    *   Configure your database connection string in the `.env` file (created by `prisma init` or `dotenv`).

3.  **Define Database Schema:**
    *   Edit `prisma/schema.prisma`.
    *   Define a `User` model with fields for `id`, `username` (unique), `hashedPassword`, and `publicKey` (store this as a string or byte array). You might also want fields for created/updated timestamps.

4.  **Run Database Migration:**
    *   Run `npx prisma migrate dev --name initial_setup` (or a descriptive name) to create the database tables based on your schema.

5.  **Implement Server-Side User Registration (`+server.js`):**
    *   Create a SvelteKit server route (e.g., `src/routes/api/register/+server.js`).
    *   Handle `POST` requests.
    *   Receive username and password from the request body.
    *   **Server-side:** Hash the password using `bcryptjs`.
    *   **Crucially:** This endpoint will also receive the user's **public key** from the client during registration.
    *   Use Prisma to create a new `User` record in the database, storing the username, hashed password, and the received public key.
    *   Return a success or failure response.

6.  **Implement Server-Side User Login (`+server.js`):**
    *   Create a SvelteKit server route (e.g., `src/routes/api/login/+server.js`).
    *   Handle `POST` requests.
    *   Receive username and password.
    *   Use Prisma to find the user by username.
    *   **Server-side:** Compare the provided password with the stored hashed password using `bcryptjs.compare()`.
    *   If login is successful, return a success response. You might want to implement session management or return a token here (though the prompt didn't explicitly require it, it's common).
    *   If login fails, return an error.

7.  **Implement Server-Side Get Users/Public Keys (`+server.js`):**
    *   Create a SvelteKit server route (e.g., `src/routes/api/users/+server.js`).
    *   Handle `GET` requests.
    *   Use Prisma to fetch a list of users, including their usernames and **public keys**. Exclude sensitive data like the hashed password.
    *   Return this list as a JSON response. This will be used for the contact list and fetching recipient public keys.

Phase 2: Client-Side Implementation & Key Management

8.  **Create Registration and Login Pages/Components:**
    *   Create Svelte pages or components for user registration and login forms.
    *   Handle form submissions.
    *   Use `fetch` to send registration/login data to your server-side API endpoints.

9.  **Implement Client-Side ECDSA Key Generation (Registration):**
    *   In your registration component/logic:
    *   When a user registers, use `window.crypto.subtle.generateKey()` to generate an ECDSA key pair (e.g., using the `P-256` curve).
    *   Export the **private key** (e.g., to JWK format) and store it securely client-side (e.g., in `localStorage`). **WARNING:** `localStorage` is not truly secure for private keys in a production environment, but it fulfills the "stored client-side" requirement for this assignment.
    *   Export the **public key** (e.g., to JWK format).
    *   Send the username, password, and the **public key** to your server's registration endpoint.

10. **Implement Client-Side Private Key Retrieval (Login):**
    *   In your login success logic:
    *   Retrieve the user's private key from client-side storage (`localStorage`). You will need this for signing messages.

Phase 3: Real-time Chat & Security Implementation

11. **Set up WebSocket Server:**
    *   Integrate the `ws` library into your SvelteKit application. A common way is to use a SvelteKit hook (`src/hooks.server.js`) or a dedicated server file to manage the WebSocket server instance and connections.
    *   Handle new connections, messages, and disconnections.
    *   Maintain a list of connected users and their associated WebSocket connections (perhaps linked by username or user ID).

12. **Set up WebSocket Client:**
    *   In your chat page/component, establish a WebSocket connection to your server.
    *   Handle incoming messages from the server.

13. **Implement Client-Side Message Sending (Signing):**
    *   In your chat input component:
    *   Get the plaintext message.
    *   **Client-side:** Hash the plaintext message using the SHA-3 library (`js-sha3`).
    *   **Client-side:** Retrieve the user's private key from storage.
    *   **Client-side:** Sign the SHA-3 hash using `window.crypto.subtle.sign()` with the private key.
    *   Construct the message object containing: sender username, receiver username, plaintext message, the calculated SHA-3 hash, and the ECDSA signature.
    *   Send this message object to the server via the WebSocket connection.

14. **Implement Server-Side Message Handling:**
    *   In your WebSocket server logic:
    *   Receive the message object from the client.
    *   Store the message in the database (plaintext, hash, signature, sender, receiver, timestamp).
    *   Forward the message object to the recipient's active WebSocket connection (if they are online).

15. **Implement Client-Side Message Receiving (Verification):**
    *   In your chat component, when a message is received via WebSocket:
    *   Extract the plaintext message, received hash, and received signature from the message object.
    *   Fetch the sender's public key (from the server via your `/api/users` endpoint, or cache it if you already have it).
    *   **Client-side:** Re-hash the received plaintext message using the SHA-3 library (`js-sha3`).
    *   **Client-side:** Use `window.crypto.subtle.verify()` with the sender's public key, the received signature, and the newly calculated SHA-3 hash.
    *   Based on the verification result (true/false):
        *   Display the message.
        *   Add a visual indicator (e.g., a "Verified" or "Unverified" label) next to the message.

Phase 4: UI & Refinement

16. **Build Contact List UI:**
    *   Fetch the list of users and their public keys from your `/api/users` endpoint when the user logs in.
    *   Display this list. Allow the user to select a contact to start a chat.

17. **Build Chat Interface UI:**
    *   Display the messages for the current chat session (fetch historical messages from the server via an API endpoint).
    *   Implement the message input area.

18. **Add Error Handling and Loading States:**
    *   Handle potential errors during API calls, WebSocket connections, and cryptographic operations.
    *   Show loading indicators where necessary.

19. **Write Tests (Using Vitest):**
    *   Write unit tests for your server-side functions (password hashing verification, API endpoint logic).
    *   Write unit tests for your client-side cryptographic functions (SHA-3 hashing, ECDSA signing/verification - you might need to mock the Web Crypto API for testing in a Node.js environment, or run tests in a browser environment).
    *   Write tests for your WebSocket message handling logic.

20. **Refine and Iterate:**
    *   Improve the user interface and user experience.
    *   Address any bugs or issues found during testing.
    *   Consider edge cases (e.g., what happens if a public key is missing?).

Phase 5: Deployment

21. **Prepare for Deployment:**
    *   Ensure your SvelteKit adapter (`@sveltejs/adapter-auto`) is correctly configured.
    *   Set up environment variables for your production database and any other secrets.

22. **Deploy:**
    *   Deploy your application to a hosting platform (e.g., Vercel, Netlify, a Node.js server).

This list provides a structured approach. Tackle these steps incrementally, testing as you go, and you'll build the application piece by piece. Good luck!